---
제목: "이펙티브 다트: 스타일"
설명: 일관적이고 읽기 쉬운 코드를 위한 형식화와 네이밍 규칙.
nextpage:
url: /guides/language/effective-dart/documentation
title: Documentation
prevpage:
url: /guides/language/effective-dart
title: Overview
---
<?code-excerpt plaster="none"?>
<?code-excerpt path-base="misc/lib/effective_dart"?>

좋은 코드의 놀랍게도 중요한 부분은 좋은 스타일입니다. 일관적인 네이밍, 배치, 형식화는 같은 코드를 똑같이 보이도록 돕습니다. 이것은 우리의 시각 시스템에 대부분의 우리가 가지고 있는 강력한 패턴 매칭 하드웨어를 이용합니다. 만약 우리가 전체적인 다트 생태계의 일관적인  스타일을 이용한다면, 우리 모두에게 서로의 코드로 부터 배우고, 기여하기 더 쉽게 만들 것입니다.

## 식별자

식별자는 다트에 3가지 특징을 가지고 있습니다.

*   `UpperCamelCase` 첫 번째를 포함하여, 각 단어의 첫 번째 글자를 키웁니다

*   `lowerCamelCase` 각 단어의 첫 번째를 키우지만, 가장 첫 번째는 소문자로 둡니다,                   줄임말이더라도요

*   `lowercase_with_underscores` 는 줄임말이더라도 소문자만 이용하고, 단어들을 `_`로 나눕니다.


### 이름 타입을은  `UpperCamelCase`를 이용`하세요`.

{% include linter-rule-mention.md rule="camel_case_types" %}

클래스, enum 타입, typedef, 그리고 타입 인자들은 각 단어의 첫 번째 글자를 키우고(가장 첫 번째 단어도 포함하여), 분리자를 사용하지 않습니다.

{:.good}
<?code-excerpt "style_good.dart (type-names)"?>
{% prettify dart tag=pre+code %}
class SliderMenu { ... }

class HttpRequest { ... }

typedef Predicate<T> = bool Function(T value);
{% endprettify %}

이것은 심지어 메타데이터 어노테이션으로 사용되도록 의도된 클래스 또한 포함합니다.

{:.good}
<?code-excerpt "style_good.dart (annotation-type-names)"?>
{% prettify dart tag=pre+code %}
class Foo {
const Foo([Object? arg]);
}

@Foo(anArg)
class A { ... }

@Foo()
class B { ... }
{% endprettify %}

만약 어노테이션 클래스의 생성자의 인자가 없으면, 여러분은 이를 위해 `lowerCamelCase` const 를 생성하고 싶어할 것입니다.

{:.good}
<?code-excerpt "style_good.dart (annotation-const)"?>
{% prettify dart tag=pre+code %}
const foo = Foo();

@foo
class C { ... }
{% endprettify %}

[Linter rule]: /guides/language/analysis-options#the-analysis-options-file

### extensions은 `UpperCamelCase`로 네이밍`하세요`.

{% include linter-rule-mention.md rule="camel_case_extensions" %}

타입과 같이 extension은 각 단어의 첫 번째 단어들을 키우고(가장 첫 번째도 포함), 분리자를 사용하지 않습니다.

{:.good}
<?code-excerpt "style_good.dart (extension-names)"?>
{% prettify dart tag=pre+code %}
extension MyFancyList<T> on List<T> { ... }

extension SmartIterable<T> on Iterable<T> { ... }
{% endprettify %}

[extensions]: /guides/language/extension-methods

### 라이브러리, 폴더, 소스 파일들은 `lowercase_with_underscores`를 이용`하세요`. {#do-name-libraries-and-source-files-using-lowercase_with_underscores}

{% include linter-rule-mention.md rule1="library_names" rule2="file_names" %}
<!-- source for rules (update these if you update the guideline):
https://github.com/dart-lang/linter/blob/master/lib/src/rules/library_names.dart
https://github.com/dart-lang/linter/blob/master/lib/src/rules/file_names.dart -->

어떤 파일 시스템은 케이스 민감하지 않습니다, 그래서 많은 프로젝트들은 모두 소문자가 되길 요구할 것입니다. 분리자를 이용하는 것은 그런 형식에서 여전히 읽기 쉽도록 합니다. 언더스코어를 분리자로 이용하는 것은 여전히 유효한 다트 식별자라는 것을 보장하는데, 그것은 언어가 뒤늦게 symbolic imports를 지원한다면 도움이 될 것입니다.

{:.good}
<?code-excerpt "style_lib_good.dart" replace="/foo\///g"?>
{% prettify dart tag=pre+code %}
library peg_parser.source_scanner;

import 'file_system.dart';
import 'slider_menu.dart';
{% endprettify %}

{:.bad}
<?code-excerpt "style_lib_good.dart" replace="/foo\///g;/file./file-/g;/slider_menu/SliderMenu/g;/source_scanner/SourceScanner/g;/peg_parser/pegparser/g"?>
{% prettify dart tag=pre+code %}
library pegparser.SourceScanner;

import 'file-system.dart';
import 'SliderMenu.dart';
{% endprettify %}

{{site.alert.note}}
이 가이드라인은 *여러분이 이름을 짓기로 한다면*, *어떻게* 라이브러리의 이름을 짓는지 명시할 것입니다.
이것은 당신이 원한다면 파일에 있는 라이브러리를 지시하는 것을 생략하더라도 괜찮습니다.
{{site.alert.end}}


### import 접두사 이름은 `lowercase_with_underscores`를 이용`하세요`.

{% include linter-rule-mention.md rule="library_prefixes" %}

{:.good}
<?code-excerpt "style_lib_good.dart (import-as)" replace="/(package):examples\/effective_dart\/foo.dart[^']*/$1:angular_components\/angular_components.dart/g; /(package):examples\/effective_dart\/bar.dart[^']*/$1:js\/js.dart/g"?>
{% prettify dart tag=pre+code %}
import 'dart:math' as math;
import 'package:angular_components/angular_components.dart' as angular_components;
import 'package:js/js.dart' as js;
{% endprettify %}

{:.bad}
<?code-excerpt "style_lib_good.dart (import-as)" replace="/(package):examples\/effective_dart\/foo.dart[^']*/$1:angular_components\/angular_components.dart/g; /as angular_components/as angularComponents/g; /(package):examples\/effective_dart\/bar.dart[^']*/$1:js\/js.dart/g; / math/ Math/g;/as js/as JS/g"?>
{% prettify dart tag=pre+code %}
import 'dart:math' as Math;
import 'package:angular_components/angular_components.dart' as angularComponents;
import 'package:js/js.dart' as JS;
{% endprettify %}


### 다른 식별자들의 이름은 `lowerCamelCase`를 이용`하세요`.

{% include linter-rule-mention.md rule="non_constant_identifier_names" %}

클래스 멤버, 탑 레벨 정의, 변수 인자, 그리고 명명된 인자들은 가장 첫 번째를 제외하고 각 단어의 첫 번째를 키우고, 구분자를 쓰지 않아야 합니다.

{:.good}
<?code-excerpt "style_good.dart (misc-names)"?>
{% prettify dart tag=pre+code %}
var count = 3;

HttpRequest httpRequest;

void align(bool clearItems) {
// ...
}
{% endprettify %}


### const 의 이름은 `lowerCamelCase`를 `선호`하세요.

{% include linter-rule-mention.md rule="constant_identifier_names" %}

새로운 코드에서는, enum 값들을 포함하여 const 변수들에는 `lowerCamelCase`를 이용하세요.

{:.good}
<?code-excerpt "style_good.dart (const-names)"?>
{% prettify dart tag=pre+code %}
const pi = 3.14;
const defaultTimeout = 1000;
final urlScheme = RegExp('^([a-z]+):');

class Dice {
static final numberGenerator = Random();
}
{% endprettify %}

{:.bad}
<?code-excerpt "style_bad.dart (const-names)"?>
{% prettify dart tag=pre+code %}
const PI = 3.14;
const DefaultTimeout = 1000;
final URL_SCHEME = RegExp('^([a-z]+):');

class Dice {
static final NUMBER_GENERATOR = Random();
}
{% endprettify %}

여러분은 아마 기존의 코드와 일관성을 위해 `SCREAMING_CAPS`를 이용할 것입니다,
다음과 같은 경우에서 처럼:

* `SCREAMING_CAPS`를 이미 사용하는 파일이나 라이브러리에 코드를 추가할 때.
* 예를 들어 [protobufs.][]에서 생성된 enum 타입처럼 자바 코드와 유사한 다크 코드를 작성할 때

{{site.alert.note}}
우리는 처음에 const 값에 자바의 `SCREAMING_CAPS` 스타일을 사용했습니다. 우리는 몇 가지 이유에 따라 변경했습니다:

*   `SCREAMING_CAPS`은 많은 경우에 나쁘게 보입니다, 특히 CSS 색과 같은 것들을 위한 부분적인 enum 값들.
*   const 값은 종종 final non-const 변수로 변경되는데, 그것은 이름의 변화가 필요하게 만들기도 합니다.
*   enum 타입에 자동적으로 정의되는 `값` 프로퍼티는 const 값이고, lowercase 입니다.
    {{site.alert.end}}

[protobufs.]: {{site.pub-pkg}}/protobuf


### 줄임말과 단어들 처럼 두 문자 이상인 축약형은 대문자화`하세요`.

대문자화된 줄임말은 읽기 어려울 수 있습니다, 그리고
여러 인접한 줄임말들은 모호한 이름이 될 수 있습니다.
예를 들어, `HTTPSFTP`로 시작되는 이름이 있을 때,
HTTPS FTP or HTTP SFTP 중 어떤 것을 의미하는 지 알기 어렵습니다.

이를 피하려면 줄임말과 축약형은 일반 단어들처럼 대문자화돼야 합니다.

**예외:** IO (입/출력)과 같은두 문자의 *줄임말*은 완전히
대문자화됐습니다: `IO`. 반대로, ID와 같은 두 문자의 *축약형*은
여전히 일반 단어들처럼 대문자화됩니다.

{:.good}
{% prettify dart tag=pre+code %}
class HttpConnection {}
class DBIOPort {}
class TVVcr {}
class MrRogers {}

var httpRequest = ...
var uiHandler = ...
var userId = ...
Id id;
{% endprettify %}

{:.bad}
{% prettify dart tag=pre+code %}
class HTTPConnection {}
class DbIoPort {}
class TvVcr {}
class MRRogers {}

var hTTPRequest = ...
var uIHandler = ...
var userID = ...
ID iD;
{% endprettify %}


### 사용되지 않은 콜백 인자들을 위해서 `_`, `__`, 등을 사용하는걸 `선호`하세요. 

때때로 콜백 함수의 타입 시그니처(type signature)는 인자를 필요로하는데,
콜백 실행은 인자를 _사용_ 하지 않습니다.
이러한 경우에는, 사용하지 않는 파라미터를 `_`로 이름짓는 것이 일반적입니다.
만약 함수가 사용하지 않는 여러 인자들이 있다면, 이름 충돌을 피하기 위해
추가적인 언더스코어를 사용하세요: `__`, `___`, 등.

{:.good}
<?code-excerpt "style_good.dart (unused-callback-params)"?>
{% prettify dart tag=pre+code %}
futureOfVoid.then((_) {
print('Operation complete.');
});
{% endprettify %}

이 가이드라인은 오직 *익명과 지역* 함수 모두를 위한 것입니다.
이 함수들은 보통 사용되지 않는 인자가 무엇인지 명확하게 나타나는 context 에서 즉시 이용됩니다.
반대로 탑 레벨 함수들과 메소드 선언은 그러한 context가 없어서,
그들의 인자들은 이름을 지어 각 인자가 무엇을 위한 것인지 명확하게 할 수 있도록 해야합니다,
심지어 사용되지 않더라도요.


### DON'T use a leading underscore for identifiers that aren't private.

Dart uses a leading underscore in an identifier to mark members and top-level
declarations as private. This trains users to associate a leading underscore
with one of those kinds of declarations. They see "_" and think "private".

There is no concept of "private" for local variables, parameters, local
functions, or library prefixes. When one of those has a name that starts with an
underscore, it sends a confusing signal to the reader. To avoid that, don't use
leading underscores in those names.


### DON'T use prefix letters.

[Hungarian notation](https://en.wikipedia.org/wiki/Hungarian_notation) and
other schemes arose in the time of BCPL, when the compiler didn't do much to
help you understand your code. Because Dart can tell you the type, scope,
mutability, and other properties of your declarations, there's no reason to
encode those properties in identifier names.

{:.good}
{% prettify dart tag=pre+code %}
defaultTimeout
{% endprettify %}

{:.bad}
{% prettify dart tag=pre+code %}
kDefaultTimeout
{% endprettify %}


## Ordering

To keep the preamble of your file tidy, we have a prescribed order that
directives should appear in. Each "section" should be separated by a blank line.

A single linter rule handles all the ordering guidelines:
[directives_ordering.](/tools/linter-rules#directives_ordering)


### DO place "dart:" imports before other imports.

{% include linter-rule-mention.md rule="directives_ordering" %}

{:.good}
<?code-excerpt "style_lib_good.dart (dart-import-first)" replace="/\w+\/effective_dart\///g"?>
{% prettify dart tag=pre+code %}
import 'dart:async';
import 'dart:html';

import 'package:bar/bar.dart';
import 'package:foo/foo.dart';
{% endprettify %}


### DO place "package:" imports before relative imports.

{% include linter-rule-mention.md rule="directives_ordering" %}

{:.good}
<?code-excerpt "style_lib_good.dart (pkg-import-before-local)" replace="/\w+\/effective_dart\///g;/'foo/'util/g"?>
{% prettify dart tag=pre+code %}
import 'package:bar/bar.dart';
import 'package:foo/foo.dart';

import 'util.dart';
{% endprettify %}


### DO specify exports in a separate section after all imports.

{% include linter-rule-mention.md rule="directives_ordering" %}

{:.good}
<?code-excerpt "style_lib_good.dart (export)"?>
{% prettify dart tag=pre+code %}
import 'src/error.dart';
import 'src/foo_bar.dart';

export 'src/error.dart';
{% endprettify %}

{:.bad}
<?code-excerpt "style_lib_bad.dart (export)"?>
{% prettify dart tag=pre+code %}
import 'src/error.dart';
export 'src/error.dart';
import 'src/foo_bar.dart';
{% endprettify %}


### DO sort sections alphabetically.

{% include linter-rule-mention.md rule="directives_ordering" %}

{:.good}
<?code-excerpt "style_lib_good.dart (sorted)" replace="/\w+\/effective_dart\///g"?>
{% prettify dart tag=pre+code %}
import 'package:bar/bar.dart';
import 'package:foo/foo.dart';

import 'foo.dart';
import 'foo/foo.dart';
{% endprettify %}

{:.bad}
<?code-excerpt "style_lib_bad.dart (sorted)" replace="/\w+\/effective_dart\///g"?>
{% prettify dart tag=pre+code %}
import 'package:foo/foo.dart';
import 'package:bar/bar.dart';

import 'foo/foo.dart';
import 'foo.dart';
{% endprettify %}


## Formatting

Like many languages, Dart ignores whitespace. However, *humans* don't. Having a
consistent whitespace style helps ensure that human readers see code the same
way the compiler does.


### DO format your code using `dart format`.

Formatting is tedious work and is particularly time-consuming during
refactoring. Fortunately, you don't have to worry about it. We provide a
sophisticated automated code formatter called [`dart format`][] that does it for
you. We have [some documentation][dart format docs] on the rules it applies, but the
official whitespace-handling rules for Dart are *whatever `dart format` produces*.

The remaining formatting guidelines are for the few things `dart format` cannot fix
for you.

[`dart format`]: /tools/dart-format
[dart format docs]: https://github.com/dart-lang/dart_style/wiki/Formatting-Rules

### CONSIDER changing your code to make it more formatter-friendly.

The formatter does the best it can with whatever code you throw at it, but it
can't work miracles. If your code has particularly long identifiers, deeply
nested expressions, a mixture of different kinds of operators, etc. the
formatted output may still be hard to read.

When that happens, reorganize or simplify your code. Consider shortening a local
variable name or hoisting out an expression into a new local variable. In other
words, make the same kinds of modifications that you'd make if you were
formatting the code by hand and trying to make it more readable. Think of
`dart format` as a partnership where you work together, sometimes iteratively,
to produce beautiful code.


### AVOID lines longer than 80 characters.

{% include linter-rule-mention.md rule="lines_longer_than_80_chars" %}

Readability studies show that long lines of text are harder to read because your
eye has to travel farther when moving to the beginning of the next line. This is
why newspapers and magazines use multiple columns of text.

If you really find yourself wanting lines longer than 80 characters, our
experience is that your code is likely too verbose and could be a little more
compact. The main offender is usually `VeryLongCamelCaseClassNames`. Ask
yourself, "Does each word in that type name tell me something critical or
prevent a name collision?" If not, consider omitting it.

Note that `dart format` does 99% of this for you, but the last 1% is you.
It does not split long string literals to fit in 80 columns,
so you have to do that manually.

**Exception:** When a URI or file path occurs in a comment or string (usually in
an import or export), it may remain whole even if it causes the line to go over
80 characters. This makes it easier to search source files for a path.

**Exception:** Multi-line strings can contain lines longer than 80 characters
because newlines are significant inside the string and splitting the lines into
shorter ones can alter the program.

### DO use curly braces for all flow control statements. {#do-use-curly-braces-for-all-flow-control-structures}

{% include linter-rule-mention.md rule="curly_braces_in_flow_control_structures" %}

Doing so avoids the [dangling else][] problem.

[dangling else]: https://en.wikipedia.org/wiki/Dangling_else

{:.good}
<?code-excerpt "style_good.dart (curly-braces)"?>
{% prettify dart tag=pre+code %}
if (isWeekDay) {
print('Bike to work!');
} else {
print('Go dancing or read a book!');
}
{% endprettify %}

**Exception:** When you have an `if` statement with no `else` clause and the
whole `if` statement fits on one line, you can omit the braces if you prefer:

{:.good}
<?code-excerpt "style_good.dart (one-line-if)"?>
{% prettify dart tag=pre+code %}
if (arg == null) return defaultValue;
{% endprettify %}

If the body wraps to the next line, though, use braces:

{:.good}
<?code-excerpt "style_good.dart (one-line-if-wrap)"?>
{% prettify dart tag=pre+code %}
if (overflowChars != other.overflowChars) {
return overflowChars < other.overflowChars;
}
{% endprettify %}

{:.bad}
<?code-excerpt "style_bad.dart (one-line-if-wrap)"?>
{% prettify dart tag=pre+code %}
if (overflowChars != other.overflowChars)
return overflowChars < other.overflowChars;
{% endprettify %}
